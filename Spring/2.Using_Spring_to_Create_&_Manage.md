# Using Spring Framework to Create and Manage Java Objects

## Primary vs Qualifier

- `@Primary` - A bean should be given preference when multiple candidates are qualified
- `@Qualifier` - A specific bean should be auto-wired (name of the bean can be used as qualifier)
- Always think from the perspective of the class using the `@Component`
  - Just `@Autowired` - Uses `@Primary`
  - `@Autowired` + `@Qualifier`: I only want ot use specific `@Component`.
  - `@Qualifier` has a higher priority than `@Primary`

## Dependency Injection Types

- **Constructor-based** : Dependencies are set by creating the Bean using its Constructor
- **Setter-based** : Dependencies are set by calling setter methods on your beans
- **Field** : No setter or constructor. Dependency is injected using reflection.

---

- `Field Injection`:

```Java
@Component
class BusinessLogic{
    @Autowired // Field Injection
    Dependency1 dependency1;
    @Autowired // Field Injection
    Dependency2 dependency2;

    public String toString() {
        return "Using " + dependency1 + " and " + dependency2;
    }
}

@Component
class Dependency1{
}

@Component
class Dependency2{
}

```

- `Setter Injection`:

```Java
@Component
class BusinessLogic{
    Dependency1 dependency1;
    Dependency2 dependency2;

    @Autowired // Setter Injection
    public void setDependency1(Dependency1 dependency1){
        this.dependency1 = dependency1;
    }

    @Autowired // Setter Injection
    public void setDependency2(Dependency2 dependency2){
        this.dependency2 = dependency2;
    }

    public String toString() {
        return "Using " + dependency1 + " and " + dependency2;
    }
}

@Component
class Dependency1{
}

@Component
class Dependency2{
}
```

- `Constructor Injection`:

```Java
@Component
class BusinessLogic{ 
    Dependency1 dependency1;
    Dependency2 dependency2;

    // @Autowired - Not Necessary for Constructor Injection
    public BusinessLogic(Dependency1 dependency1, Dependency2 dependency2){
      this.dependency1 = dependency1;
      this.dependency2 = dependency2;
    }

    public String toString() {
        return "Using " + dependency1 + " and " + dependency2;
    }
}

@Component
class Dependency1{
}

@Component
class Dependency2{
}
```

> The Spring team recommends Constructor-based injection.

## Important Terminology - Spring Framework

- `@Component`: An instance of class will be managed by **Spring Framework**.
- `Dependency`: **GameRunner** needs **GamingConsole** implemented.
  - **GamingConsole** implements (eg.**MarioGame**) is a dependency of **GameRunner**.
- `Component Scan`: It's how Spring Framework find component classes
  - It scans packages.
  - if `@ComponentScan` isn't specified, it will take the current file package and use that to scan.
  - Otherwise, it will scan it's specified file path `@ComponentScan("<specified_file_path>")`
- [`Dependency Injection`](#dependency-injection-types): Identify beans, their dependencies and wire them together (provides **IoC** - Inversion of Control)
  - `Spring Beans`: An object managed by Spring Framework.
  - `IoC Container`: Manages the lifecycle of beans and dependencies.
    - `Application Context` (Complex)
    - `BeanFactory` (Simple) - rarely used.
  - `Autowiring`:

---

- Component Scan:

```Java
@Configuration
@ComponentScan
public class SomethingElse {
    // Some code
}
```
